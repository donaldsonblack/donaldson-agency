name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch: # Allow manual triggers

env:
  DOCKER_IMAGE: donaldson-agency
  DEPLOY_PATH: /opt/donaldson-agency

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run linter
        run: bun run lint

      - name: Type check
        run: bunx tsc --noEmit

      - name: Build application
        run: bun run build
        env:
          # Dummy values for build (actual values set on server)
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          RESEND_FROM_EMAIL: ${{ secrets.RESEND_FROM_EMAIL }}
          RESEND_TO_EMAIL: ${{ secrets.RESEND_TO_EMAIL }}
          NEXT_PUBLIC_GA_MEASUREMENT_ID: ${{ secrets.NEXT_PUBLIC_GA_MEASUREMENT_ID }}

  deploy:
    name: Deploy to Server
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            set -e

            echo "üöÄ Starting deployment..."
            cd ${{ env.DEPLOY_PATH }}

            # Store current container ID for rollback
            CURRENT_CONTAINER=$(docker ps -q -f name=${{ env.DOCKER_IMAGE }})
            echo "Current container: $CURRENT_CONTAINER"

            # Store current image ID for rollback
            CURRENT_IMAGE=$(docker images -q ${{ env.DOCKER_IMAGE }}:latest)
            echo "Current image: $CURRENT_IMAGE"

            # Tag current image as backup (if exists)
            if [ ! -z "$CURRENT_IMAGE" ]; then
              echo "üì¶ Creating backup of current image..."
              docker tag ${{ env.DOCKER_IMAGE }}:latest ${{ env.DOCKER_IMAGE }}:backup || true
            fi

            # Pull latest code
            echo "üì• Pulling latest code..."
            git fetch origin main
            git reset --hard origin/main

            # Build new image
            echo "üî® Building new Docker image..."
            docker compose build --no-cache

            # Stop current container
            echo "üõë Stopping current container..."
            docker compose down || true

            # Start new container
            echo "‚ñ∂Ô∏è  Starting new container..."
            docker compose up -d

            # Wait for health check
            echo "‚è≥ Waiting for container to be healthy..."
            sleep 15

            # Check if container is running and healthy
            if docker compose ps | grep -q "Up"; then
              # Test if the app responds
              if curl -f -s http://localhost:3000 > /dev/null; then
                echo "‚úÖ Deployment successful!"

                # Clean up old backup image
                if [ ! -z "$CURRENT_IMAGE" ]; then
                  docker rmi ${{ env.DOCKER_IMAGE }}:backup 2>/dev/null || true
                fi

                # Clean up dangling images
                docker image prune -f

                exit 0
              else
                echo "‚ùå Health check failed - app not responding!"
                exit 1
              fi
            else
              echo "‚ùå Container failed to start!"
              exit 1
            fi

      - name: Rollback on failure
        if: failure()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            set -e

            echo "üîÑ Deployment failed! Rolling back..."
            cd ${{ env.DEPLOY_PATH }}

            # Stop failed container
            docker compose down || true

            # Check if backup image exists
            if docker images | grep -q "${{ env.DOCKER_IMAGE }}.*backup"; then
              echo "üì¶ Restoring backup image..."

              # Remove failed image
              docker rmi ${{ env.DOCKER_IMAGE }}:latest 2>/dev/null || true

              # Restore backup
              docker tag ${{ env.DOCKER_IMAGE }}:backup ${{ env.DOCKER_IMAGE }}:latest

              # Start old container
              docker compose up -d

              # Wait and verify
              sleep 10

              if docker compose ps | grep -q "Up"; then
                echo "‚úÖ Rollback successful! Service restored."
              else
                echo "‚ùå Rollback failed! Manual intervention required."
                exit 1
              fi
            else
              echo "‚ö†Ô∏è  No backup image found. Manual intervention required."
              exit 1
            fi

      - name: Notify on success
        if: success()
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Site is live at your production URL"

      - name: Notify on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed and rollback was attempted"
          echo "üìß Check your server logs for details"
